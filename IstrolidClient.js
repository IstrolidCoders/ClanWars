/*
 * var {IstrolidClient} = require('./IstrolidClient.js');
 * var istroClient = new IstrolidClient(serverName);
 * istroClient.on(event, () =>{});
 * istroClient.close();
 *
 * event can be message, server, serverchange, gameended, gamestarting
 */
var WebSocket = require('websocket').w3cwebsocket;
var util = require('util');
var {EventEmitter} = require('events');

var rootAddress = "ws://198.199.109.223:88";
var wsOptions = {
    maxReceivedFrameSize: 0x200000
};

var VERSION = 48;
var MINOR_VERSION = 3;

var account = {
    email: "r11010@mail.com",
    token: "332f0722726ab883bac1f65c4a0749f0752160a1"
};

var commander = null;

var IstrolidClient = function(serverName) {
    this.intp = null;
    this.network = null;
    this.rootNet = null;
    this.serverName = serverName;
    this.global = serverName ? false : true;

    this.chat = {
        players: {},
        lines: []
    };

    this.connect = function() {
        this.rootNet = new RootConnection(rootAddress);
        account.signin();
    };

    this.sendMessage = function(msg) {
        if(this.global)
            this.rootNet.send("message", {text: msg});
        else
            this.rootNet.send("message", {text: msg, channel: serverName});
    };

    this.close = function() {
        if(this.network)
            this.network.close();
        this.rootNet.close();
    };

    this.joinServer = function() {
        if(this.global) return;

        var base, ref;
        var server = (ref = this.rootNet.servers) != null ? ref[serverName] : void 0;
        if (!server) {
            //console.log("server not found");
            return;
        }
        this.intp = new Interpolator(this);
        if (this.network != null) {
            if (typeof this.network.close === "function") {
                this.network.close();
            }
        }
        this.network = new Connection(server.address);
        this.chat.channel = serverName;
        this.rootNet.sendMode();
    };

    //from src/network.js
    // Generated by CoffeeScript 1.10.0
    (function(IstrolidClient_this) {
        var getAIRules,
            slice = [].slice;

        Connection = (function() {
            function Connection(address) {
                this.address = address;
                //console.log("connecting to", this.address);
                this.connect();
            }

            Connection.prototype.connect = function() {
                this.websocket = new WebSocket(this.address, undefined, undefined, undefined, undefined, wsOptions);
                //this.websocket.binaryType = 'arraybuffer';
                //console.log("websocket", this.websocket);
                this.websocket.onopen = (function(_this) {
                    return function(e) {
                        //console.log("ws open"/*, e*/);
                        _this.sendPlayer();
                        //console.log("sending game key", commander.name, IstrolidClient_this.rootNet.gameKey);
                        _this.send("gameKey", commander.name, IstrolidClient_this.rootNet.gameKey);
                    };
                })(this);
                this.websocket.onclose = (function(_this) {
                    return function(e) {
                        //console.log("ws close");
                    };
                })(this);
                this.websocket.onmessage = (function(_this) {
                    return function(e) {
                        var data, packet;
                        packet = new DataView(e.data);
                        data = IstrolidClient_this.intp.zJson.loadDv(packet);
                        //console.log("Msg: " + JSON.stringify(data).substring(0, 500));
                        return IstrolidClient_this.intp.recv(data);
                    };
                })(this);
                return this.websocket.onerror = (function(_this) {
                    return function(e) {
                        //console.log("ws error", e);
                    };
                })(this);
            };

            Connection.prototype.close = function() {
                this.websocket.close();
            }

            Connection.prototype.send = function() {
                var args, dv;
                args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                if (this.websocket.readyState === 1) {
                    //console.log("Send: " + JSON.stringify(args));
                    dv = IstrolidClient_this.intp.zJson.dumpDv(args);
                    return this.websocket.send(dv.buffer);
                }
            };

            Connection.prototype.sendPlayer = function() {
                var buildBar, i, j;
                if (!commander) {
                    return;
                }
                buildBar = [null, null, null, null, null, null, null, null, null, null];
                /*
            for (i = j = 0; j < 10; i = ++j) {
                if (validSpec(commander, commander.buildBar[i])) {
                    buildBar[i] = fromShort(commander.buildBar[i]);
                }
            }
            */
                return this.send("playerJoin", commander.id, commander.name, commander.color, buildBar, getAIRules());
            };

            Connection.prototype.close = function() {
                return this.websocket.close();
            };

            return Connection;

        })();

        RootConnection = (function() {
            function RootConnection(address) {
                this.address = address;
                this.connect();
            }

            RootConnection.prototype.connect = function() {
                this.startTime = Date.now();
                this.websocket = new WebSocket(this.address, undefined, undefined, undefined, undefined, wsOptions);
                this.websocket.onopen = (function(_this) {
                    return function(e) {
                        //console.log("Connect");
                        //onecup.refresh();
                        account.lastRootSave = {};
                        account.connectedToRoot();
                        return _this.sendMode();
                    };
                })(this);
                this.websocket.onclose = (function(_this) {
                    return function(e) {
                        //onecup.refresh();
                        //return console.log("root ws close");
                    };
                })(this);
                this.websocket.onmessage = (function(_this) {
                    return function(e) {
                        var _, k, msg, name, player, ref, ref1, ref2, ref3, s, server, v;
                        //onecup.refresh();
                        //console.log("RMsg: " + e.data.substring(0, 200));
                        msg = JSON.parse(e.data);
                        switch (msg[0]) {
                            case "serversStats":
                                return _this.serversStats = msg[1];
                            case "servers":
                                _this.servers = {};
                                ref = msg[1];
                                for (_ in ref) {
                                    s = ref[_];
                                    _this.servers[s.name] = s;
                                    IstrolidClient_this.emit('server', s);
                                    if(s.name === serverName) {
                                        IstrolidClient_this.joinServer();
                                    }
                                }
                                //return onecup.refresh();
                            case "serversDiff":
                                ref2 = msg[1];
                                for (name in ref2) {
                                    server = ref2[name];
                                    if (server === null) {
                                        delete _this.servers[name];
                                    } else {
                                        if (_this.servers[name] == null) {
                                            _this.servers[name] = {};
                                        }
                                        for (k in server) {
                                            v = server[k];
                                            _this.servers[name][k] = v;
                                        }
                                    }
                                }
                                //return onecup.refresh();
                            case "players":
                                IstrolidClient_this.chat.players = msg[1];
                                //return onecup.refresh();
                            case "playersDiff":
                                ref3 = msg[1];
                                for (name in ref3) {
                                    player = ref3[name];
                                    if (player === null) {
                                        delete IstrolidClient_this.chat.players[name];
                                    } else {
                                        if (IstrolidClient_this.chat.players[name] == null) {
                                            IstrolidClient_this.chat.players[name] = {};
                                        }
                                        for (k in player) {
                                            v = player[k];
                                            IstrolidClient_this.chat.players[name][k] = v;
                                        }
                                    }
                                }
                                //return onecup.refresh();
                            case "message":
                                msg[1].time = Date.now();
                                IstrolidClient_this.chat.lines.push(msg[1]);
                                if(msg[1].text && (!msg[1].channel || msg[1].channel === serverName))
                                    IstrolidClient_this.emit('message', msg[1]);
                                break;
                                /*
                            return after(100, function() {
                                var chatarea;
                                chatarea = document.getElementById("chatarea");
                                if (chatarea) {
                                    return chatarea.scrollTop = 100000;
                                }
                            });
                            */
                            case "messageLog":
                                msg[1].time = 0;
                                return IstrolidClient_this.chat.lines.push(msg[1]);
                            case "authError":
                                return account.authError(msg[1]);
                                //case "authPasswordChanged":
                                //    return ui.changePassword = false;
                            case "login":
                                return account.signinReply(msg[1]);
                                //case "windowClose":
                                //    return close();
                                //case "modInfo":
                                //    console.log("modInfo", msg);
                                //    return mod.info = msg[1];
                                //case "modLog":
                                //    console.log("modLog", msg);
                                //    return mod.log = msg[1];
                            case "gameKey":
                                return _this.gameKey = msg[1];
                        }
                    };
                })(this);
                return this.websocket.onerror = (function(_this) {
                    return function(e) {
                        return console.log("root ws error", e);
                    };
                })(this);
            };

            RootConnection.prototype.close = function() {
                this.websocket.close();
            };

            RootConnection.prototype.send = function() {
                var args;
                args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                if (this.websocket.readyState === 1) {
                    //console.log("RSend: " + JSON.stringify(args));
                    return this.websocket.send(JSON.stringify(args));
                }
            };

            RootConnection.prototype.playerMode = function() {
                /*
            var mode;
            mode = ui.mode;
            if (mode === "battle") {
                if (sim.galaxyStar) {
                    mode = "galaxy*";
                } else if (sim.challenge) {
                    mode = "challenge*";
                } else if (sim.local) {
                    mode = "local*";
                }
            }
            return mode;
            */
                return "bot";
            };

            RootConnection.prototype.sendMode = function() {
                return this.send("setMode", this.playerMode(), IstrolidClient_this.chat.channel);
            };

            return RootConnection;

        })();

        getAIRules = function() {
            /*
        if (localStorage.useAi !== "true") {
            return null;
        }
        return ais.buildBar2aiRules(commander.buildBar);
        */
            return null;
        };

    })(this);

    //from src/account.js
    // Generated by CoffeeScript 1.10.0
    (function(IstrolidClient_this) {
        var afterTimeout, isValidEmail, isValidName, spacer;

        //eval(onecup["import"]());

        afterTimeout = function(ms, fn) {
            return setTimeout(fn, ms);
        };

        account.signedIn = false;

        account.wating = false;

        account.error = false;

        account.autoSigningIn = false;

        account.name = typeof steam !== "undefined" && steam !== null ? steam.name : void 0;

        account.load = function() {
            var c, ref;
            //c = db.load("commander");
            if (c) {
                account.name = c.name;
                account.color = c.color;
                account.email = c.email;
                account.token = c.token;
            } else {
                account.color = choose(colors.nice);
            }
            /*
    if (onecup.params.token && onecup.params.email) {
      account.token = onecup.params.token;
      account.email = onecup.params.email;
      account.passworedReset = true;
      if (onecup.params.token) {
        if (typeof history !== "undefined" && history !== null) {
          history.pushState({}, "game", location.pathname);
        }
      }
    }
    */
            if (typeof require !== "undefined" && require !== null) {
                account.loadDLC();
            }
            if (((ref = location) != null ? ref.href.indexOf("gamedev.html") : void 0) !== -1) {
                account.DLCs['Curves and Shadows'] = true;
                account.DLCs['Paint Job'] = true;
                return account.DLCbonus = true;
            }
        };

        account.connectedToRoot = function() {
            account.fingerprint = "f13c5c41325ca9f420f83a176b21dfcb"; // Hash of 123456789
            if (account.token && account.email) {
                account.autoSigningIn = true;
                account.signin();
                return account.authTab = "Sign In";
            }
        };

        account.fix = function() {
            var buildBar, fk, fv, i, j, l, len, m, n, o, part, ref, ref1, ref2, ref3, results, ship, specParts, unit;
            if (!commander.buildBar) {
                commander.buildBar = ["", "", "", "", "", "", "", "", "", ""];
            }
            if (!Array.isArray(commander.buildBar) || commander.buildBar.length !== 10) {
                buildBar = ["", "", "", "", "", "", "", "", "", ""];
                if ((typeof commander.buildBar) === "object") {
                    for (i = j = 0; j < 10; i = ++j) {
                        ship = commander.buildBar[i];
                        if (ship) {
                            buildBar[i] = ship;
                        }
                    }
                }
                commander.buildBar = buildBar;
            }
            if ((ref = commander.aiRules) != null ? ref.length = 10 : void 0) {
                for (i = l = 0; l < 10; i = ++l) {
                    if (((ref1 = commander.aiRules[i]) != null ? ref1.length : void 0) > 0 && commander.buildBar[i]) {
                        unit = new types.Unit(commander.buildBar[i]);
                        if (unit.aiRules.length > 0) {
                            break;
                        }
                        specParts = [];
                        ref2 = unit.parts;
                        for (m = 0, len = ref2.length; m < len; m++) {
                            part = ref2[m];
                            specParts.push({
                                pos: [part.pos[0], part.pos[1]],
                                type: part.constructor.name,
                                dir: part.dir
                            });
                        }
                        //console.log(i + ": add AI rules to build bar", commander.aiRules[i], commander.buildBar[i]);
                        commander.buildBar[i] = toShort({
                            parts: specParts,
                            name: unit.name,
                            aiRules: commander.aiRules[i]
                        });
                    }
                    commander.aiRules[i] = [];
                }
            }
            if (!commander.galaxy) {
                commander.galaxy = {};
            }
            if (!commander.settings) {
                commander.settings = {};
            }
            if (commander.settings["Follow Units"]) {
                commander.settings["Focus Fire/Follow"] = commander.settings["Follow Units"];
                delete commander.settings["Follow Units"];
            }
            if (!commander.buildQ) {
                commander.buildQ = [];
            }
            if (!commander.selection) {
                commander.selection = [];
            }
            if (!commander.validBar) {
                commander.validBar = [true, true, true, true, true, true, true, true, true, true];
            }
            if (!commander.fleet) {
                commander.fleet = {};
            }
            if (!commander.fleet.ais) {
                commander.fleet.ais = {};
            }
            if (!commander.fleet.selection) {
                commander.fleet.selection = 0;
            }
            for (i = n = 0; n < 10; i = ++n) {
                if (!commander.fleet["0," + i] && commander.buildBar[i]) {
                    commander.fleet["0," + i] = commander.buildBar[i];
                }
            }
            if (!commander.friends) {
                commander.friends = {};
            }
            if (!commander.mutes) {
                commander.mutes = {};
            }
            if (!commander.id) {
                commander.id = rid();
            }
        };

        account.simpleCommander = function() {
            return {
                email: commander.email,
                token: commander.token,
                id: commander.id,
                name: commander.name,
                color: commander.color,
                faction: commander.faction,
                friends: commander.friends,
                version: VERSION + "." + MINOR_VERSION,
                buildBar: commander.buildBar,
                fleet: commander.fleet,
                aiRules: commander.aiRules,
                galaxyDifficulty: commander.galaxyDifficulty,
                galaxy: commander.galaxy,
                settings: commander.settings,
                mutes: commander.mutes,
                friends: commander.friends
            };
        };

        account.signin = function() {
            account.waiting = true;
            account.error = "";
            if (!account.token && account.password) {
                account.token = account.hashPass(account.password);
            }
            return IstrolidClient_this.rootNet.send("authSignIn", {
                email: account.email,
                token: account.token,
                fingerprint: account.fingerprint,
                steamid: typeof steam !== "undefined" && steam !== null ? steam.id : void 0
            });
        };

        account.authError = function(message) {
            console.log("account.authError", message);
            account.error = message;
            account.waiting = false;
            account.autoSigningIn = false;
            return account.signedIn = false;
        };

        account.signinReply = function(rootPlayer) {
            account.waiting = false;
            account.error = false;
            account.autoSigningIn = false;
            if (commander) {
                //console.log("is a reconnect, keep local commander");
                account.fix();
            } else {
                //console.log("logging in, grab command from root");
                commander = rootPlayer;
                account.fix();
            }
            account.name = commander.name;
            account.color = commander.color;
            account.email = commander.email;
            account.token = commander.token;
            account.signedIn = true;
            if (typeof IstrolidClient_this.network !== "undefined" && IstrolidClient_this.network !== null) {
                IstrolidClient_this.network.sendPlayer();
            }
            //galaxyMode.load();
            if (typeof IstrolidClient.rootNet !== "undefined" && IstrolidClient.rootNet !== null) {
                IstrolidClient.rootNet.sendMode();
            }
        };

        account.register = function() {
            account.waiting = true;
            account.error = "";
            //console.log("register", [account.name, account.email, account.password]);
            if (!isValidName(account.name)) {
                account.error = "Please use ASCII letters and numbers for name";
                return;
            }
            if (!isValidEmail(account.email)) {
                account.error = "Invalid Email";
                return;
            }
            if (!account.password) {
                account.error = "Enter a password";
                return;
            }
            account.token = account.hashPass(account.password);
            return IstrolidClient.rootNet.send("authRegister", {
                name: account.name,
                color: account.color,
                email: account.email,
                token: account.token,
                fingerprint: account.fingerprint
            });
        };

        account.hashPass = function(pass) {
            return sha1("fhs2:" + account.email + ":" + pass);
        };

        account.DLCs = {};

        account.loadDLC = function() {
            return typeof steam !== "undefined" && steam !== null ? steam.loadDLC() : void 0;
        };

        account.hasDLC = function(dlcName) {
            if (!dlcName) {
                return true;
            }
            return account.DLCs[dlcName];
        };

        account.hasDLCBonus = function() {
            return account.DLCbonus;
        };

        isValidEmail = function(email) {
            var re;
            re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
            return re.test(email);
        };

        isValidName = function(name) {
            var re;
            re = /^[A-Za-z0-9]+$/;
            return re.test(name);
        };

    })(this);
};

util.inherits(IstrolidClient, EventEmitter);

//from src/protocol.js
// Generated by CoffeeScript 1.10.0
var prot = {};

prot.commonWords = "1v1\n1v1r\n2v2\n3v3\n@attackTypes enemy @unitTypes within #m\n@attackTypes enemy that is @absoluteTypes then # within #m\n@attackTypes enemy that is @relativeTypes and @relativeTypes within #m\n@attackTypes enemy within #m\n@capTypes Command Points within #m\naction\naddAi\nai\nAi1\nAi3\nAi4\naiRules\nalpha\nAOEWarhead\napm\nArtilleryTurret\nAttack\nAutoTurret\nAvoid #dps danger areas\nAvoid everything\nAvoid over #damage shots\nBackstab\nBattery1x1\nBattery1x2\nBattery2x1\nBattery2x2\nBattleship\nbeta\nBomb\nBomber\nBomber\nBombGun\nbuildQ\nbuildRq\nBulletSpeedMod\nburn\ncapping\ncapps\nCapture\nCarrier\nCarrier\nCircle\ncloak\nCloak Counter Need\nCloaked\nCloakGenerator\ncolor\nCommandPoint\nconnected\nCruiser\nDamageMod\ndead\nDestroyer\nDestroyer\ndir\nDroneBody\nEMPGun\nEMPGun2\nEmpty\nEnemy Army Middle\nEnemy Spawn\nenergy\nEnergyTransfer\nEngine01\nEngine02\nEngine03\nEngine04\nEngine05\nEngine06\nEngine07\nFaction1\nFaction2\nFaction3\nFaction4\nFaction5\nFaction6\nFaction7\nFaster\nField # at priority #\nField # at start\nField # for # of @needTypes at priority #\nField # for # of enemy @unitTypes at priority #\nField # for # of ship in slot # at priority #\nField # when money over # at priority #\nFighter\nfillColor\nFind recharger\nFind units that are out of energy\nFlackTurret\nFlameTurret\nFlee\nFlee enemies\nFollow\nFriendly Army Middle\nFriendly Spawn\nFriendly Spawn\nfullUpdate\nghostCopy\ngoto\nGoto @locationTypes\nGuard\nHAarmor1x2Curved\nHArmor1x1\nHArmor1x1Angle\nHArmor1x1AngleBack\nHArmor1x2\nHArmor1x2Back1\nHArmor1x2Back2\nHArmor1x2Curved2\nHArmor1x2Font1\nHArmor1x2Front2\nHArmor2x1\nHArmor2x1Curved2\nHArmor2x2\nHArmor2x2Angle\nHArmor2x2AngleBack\nHArmor2x2Back1\nHArmor2x2Back2\nHArmor2x2Curved\nHArmor2x2Front1\nHArmor2x2Front2\nHeavyBeamTurret\nHeavyPDTurret\nHold Position\nholdPosition\nhost\nhp\nimage\nimg/debree/acloud01.png\nimg/debree/acloud02.png\nimg/debree/acloud03.png\nimg/debree/acloud04.png\nimg/debree/bigdebree01.png\nimg/debree/bigdebree02.png\nimg/debree/bigdebree03.png\nimg/debree/bigdebree04.png\nimg/debree/bigdebree05.png\nimg/debree/bigdebree06.png\nimg/debree/bigdebree07.png\nimg/debree/bigdebree08.png\nimg/debree/bigdebree09.png\nimg/debree/bigdebree10.png\nimg/debree/bigdebree11.png\nimg/debree/bigdebree12.png\nimg/debree/civ01.png\nimg/debree/civ02.png\nimg/debree/civ03.png\nimg/debree/civ04.png\nimg/debree/civ05.png\nimg/debree/debree01.png\nimg/debree/debree02.png\nimg/debree/debree03.png\nimg/debree/debree04.png\nimg/debree/debree05.png\nimg/debree/debree06.png\nimg/debree/debree07.png\nimg/debree/debree08.png\nimg/debree/debree09.png\nimg/debree/debree10.png\nimg/debree/debree11.png\nimg/debree/debree12.png\nimg/debree/debree13.png\nimg/debree/debree14.png\nimg/debree/debree15.png\nimg/debree/debree16.png\nimg/debree/debree17.png\nimg/debree/debree18.png\nimg/debree/debree19.png\nimg/debree/debree20.png\nimg/debree/debree21.png\nimg/debree/debree22.png\nimg/debree/debree23.png\nimg/debree/debree24.png\nimg/debree/debree25.png\nimg/debree/gcloud01.png\nimg/debree/gcloud02.png\nimg/debree/gcloud03.png\nimg/debree/gcloud04.png\nimg/debree/scloud01.png\nimg/debree/scloud02.png\nimg/debree/scloud03.png\nimg/debree/scloud04.png\nimg/debree/vcloud01.png\nimg/debree/vcloud02.png\nimg/debree/vcloud03.png\nimg/debree/vcloud04.png\nimg/dodads/bigdodad01.png\nimg/dodads/bigdodad02.png\nimg/dodads/bigdodad03.png\nimg/dodads/bigdodad04.png\nimg/dodads/bigdodad05.png\nimg/dodads/meddodad01.png\nimg/dodads/meddodad02.png\nimg/dodads/meddodad03.png\nimg/dodads/meddodad04.png\nimg/point02.png\nimg/rocks/lrock01.png\nimg/rocks/lrock02.png\nimg/rocks/lrock03.png\nimg/rocks/lrock04.png\nimg/rocks/lrock05.png\nimg/rocks/mrock01.png\nimg/rocks/mrock02.png\nimg/rocks/mrock03.png\nimg/rocks/mrock04.png\nimg/rocks/mrock05.png\nimg/rocks/mrock06.png\nimg/rocks/srock01.png\nimg/rocks/srock02.png\nimg/rocks/srock03.png\nimg/rocks/srock04.png\nimg/rocks/srock05.png\nimg/rocks/srock06.png\nimg/rocks/srock07.png\nimg/rocks/srock08.png\nInterceptor\nJumpEngine\nkickPlayer\nkills\nKite\nLess Brawling Value\nLess DPS\nLess expensive\nLess HP\nLess Range\nLetter0\nLetter1\nLetter2\nLetter3\nLetter4\nLetter5\nLetter6\nLetter7\nLetter8\nLetter9\nLetterA\nLetterB\nLetterC\nLetterD\nLetterDot\nLetterE\nLetterF\nLetterG\nLetterH\nLetterI\nLetterJ\nLetterK\nLetterL\nLetterM\nLetterN\nLetterO\nLetterP\nLetterPound\nLetterQ\nLetterR\nLetterS\nLetterT\nLetterU\nLetterV\nLetterW\nLetterX\nLetterY\nLetterZ\nLightBeamTurret\nmessage\nMineTurret\nMissileTurret\nmoney\nmoneyEarned\nMore Arc\nMore Brawling Value\nMore DPS\nMore expensive\nMore HP\nMore Range\nMore Range\nMount10Range\nMount180\nMount270\nMount30\nMount360\nMount360Micro\nMount90\nmouse\nmouseMove\nMove\nmoveOrder\nname\nNo PD\nNot Cloaked\nnumbers\nOverKillAi\nowner\nPad2x2\npartId\nparts\npartTargetId\npartWorking\nPDTurret\nperf\nPlasmaTurret\nplayerJoin\nplayerNumber\nplayers\nplayerSelected\npos\nProtect\nradius\nrallyPoint\nRam\nReactor1x1\nReactor1x2\nReactor2x1\nReactor2x2\nReloaderMod\nRest\nRest\nRingTurret\nRock\nrockColor\nrot\nrunning\nScout\nSelf Destruct\nsend other\nsend players\nsend things\nsend things fields\nsend things parts\nsend things roots\nsend zJson\nserverType\nShadowNArmor1x1\nShadowNArmor1x2\nShadowNArmor2x1\nShadowNArmor2x2\nShadowNArmor2x2Angle\nShapedWarhead\nshield\nShieldGen1x1\nShieldGen2x1\nShieldGen2x2\nside\nsim\nsize\nSlower\nSniperGun\nSolar1x1\nSolar2x2\nSolar3x3\nspacesRebuild\nSpawnPoint\nspec\nsplayers\nspotColor\nSpread to\nstartGame\nStasisField\nstate\nStay at range\nStay in #m range of friendly units\nStay in #m range of slot # units\nStayaway in #m range from slot # units\nstep\nsthings\nStop\nstopOrder\nStripe1x1\nStripe1x1Corner\nStripe1x2\nStripe2x1\nStripe2x2\nStripe2x2Corner\nStripe2x2Round\nStripeDouble2x1\nStripeDouble2x2\nStronger\nSwarmer\nSymbolDecal1\nSymbolDecal10\nSymbolDecal11\nSymbolDecal12\nSymbolDecal13\nSymbolDecal14\nSymbolDecal15\nSymbolDecal16\nSymbolDecal17\nSymbolDecal18\nSymbolDecal19\nSymbolDecal2\nSymbolDecal20\nSymbolDecal21\nSymbolDecal22\nSymbolDecal23\nSymbolDecal24\nSymbolDecal3\nSymbolDecal4\nSymbolDecal5\nSymbolDecal6\nSymbolDecal7\nSymbolDecal8\nSymbolDecal9\nTargetingMod\nTeslaTurret\ntheme\nthingId\nthings\ntimeings\nTorpTurret\ntreeform\nTry to field # every # seconds\ntype\nUArmor1x1\nUArmor1x1Angle\nUArmor1x1AngleBack\nUArmor1x1Notch1\nUArmor1x1Notch2\nUArmor1x1Spike\nUArmor1x2\nUArmor1x2Notch1\nUArmor1x2Notch2\nUArmor2x1\nUArmor2x2\nUnit\nunitsBuilt\nunitsCollide\nvalidBar\nVArmor1x1\nVArmor1x1Angle\nVArmor1x1Corner1\nVArmor1x1Corner2\nVArmor1x1Corner3\nVArmor1x1CornerBack\nVArmor1x1Curve\nVArmor1x1Hook\nVArmor1x2\nVArmor1x2Corner4\nVArmor1x2Curved\nVArmor1x2End\nVArmor1x2IBeam\nVArmor1x2SideBar\nVArmor1x2SideBarFilled\nVArmor2x1Curved\nVArmor2x2\nVArmor2x2Angle\nVArmor2x2Curve\nVArmor2x2Curved\nvel\nwarpIn\nWavePullTurret\nWavePushTurret\nWeaker\nWhen #% of energy, @chargeTypes\nWing1x1Angle\nWing1x1Notch\nWing1x1Round\nWing1x2\nWing2x1\nWing2x2\nwinningSide\nz".split("\n");

/*
  afk
  waiting
  */

var sha1 = function(msg) {
    fcc = String.fromCharCode;
    function rotl(n,s) { return n<<s|n>>>32-s; };
    function tohex(i) { for(var h="", s=28;;s-=4) { h+=(i>>>s&0xf).toString(16); if(!s) return h; } };
    var H0=0x67452301, H1=0xEFCDAB89, H2=0x98BADCFE, H3=0x10325476, H4=0xC3D2E1F0, M=0x0ffffffff;
    var i, t, W=new Array(80), ml=msg.length, wa=new Array();
    msg += fcc(0x80);
    while(msg.length%4) msg+=fcc(0);
    for(i=0;i<msg.length;i+=4) wa.push(msg.charCodeAt(i)<<24|msg.charCodeAt(i+1)<<16|msg.charCodeAt(i+2)<<8|msg.charCodeAt(i+3));
    while(wa.length%16!=14) wa.push(0);
    wa.push(ml>>>29),wa.push((ml<<3)&M);
    for( var bo=0;bo<wa.length;bo+=16 ) {
        for(i=0;i<16;i++) W[i]=wa[bo+i];
        for(i=16;i<=79;i++) W[i]=rotl(W[i-3]^W[i-8]^W[i-14]^W[i-16],1);
        var A=H0, B=H1, C=H2, D=H3, E=H4;
        for(i=0 ;i<=19;i++) t=(rotl(A,5)+(B&C|~B&D)+E+W[i]+0x5A827999)&M, E=D, D=C, C=rotl(B,30), B=A, A=t;
        for(i=20;i<=39;i++) t=(rotl(A,5)+(B^C^D)+E+W[i]+0x6ED9EBA1)&M, E=D, D=C, C=rotl(B,30), B=A, A=t;
        for(i=40;i<=59;i++) t=(rotl(A,5)+(B&C|B&D|C&D)+E+W[i]+0x8F1BBCDC)&M, E=D, D=C, C=rotl(B,30), B=A, A=t;
        for(i=60;i<=79;i++) t=(rotl(A,5)+(B^C^D)+E+W[i]+0xCA62C1D6)&M, E=D, D=C, C=rotl(B,30), B=A, A=t;
        H0=H0+A&M;H1=H1+B&M;H2=H2+C&M;H3=H3+D&M;H4=H4+E&M;
    }
    return tohex(H0)+tohex(H1)+tohex(H2)+tohex(H3)+tohex(H4);
};

var deepCopy = function(src) {
    var i, j, key, len, ret, thing;
    if (Array.isArray(src)) {
        ret = [];
        for (i = j = 0, len = src.length; j < len; i = ++j) {
            thing = src[i];
            ret[i] = deepCopy(thing);
        }
        return ret;
    }
    if (typeof src === 'object') {
        ret = {};
        for (key in src) {
            if (!src.hasOwnProperty(key)) continue;
            ret[key] = deepCopy(src[key]);
        }
        return ret;
    }
    return src;
};

var now = function() {
    var n, ref, s;
    if (typeof process !== "undefined" && process !== null) {
        ref = process.hrtime(), s = ref[0], n = ref[1];
        return (s * 1000000 + n / 1000) / 1000;
    } else {
        return performance.now();
    }
};


//from src/zjson.js
// Generated by CoffeeScript 1.10.0

/*
zjson - binary json sirelizer with some strange features

 * It does hte basic json to bin and bin to json
 * You can Diffs and send thouse instead
 * You can add a Strings table
    list wich both ends need to agree on
    usuly used for keys that are present in every msg
    */

(function() {
    var COLLECT_STATS, MAX16, MAX32, MAX8, toHex;

    Number.prototype.isInt = function(n) {
        return n !== "" && !isNaN(n) && Math.round(n) === n;
    };

    Number.prototype.isFloat = function(n) {
        return n !== "" && !isNaN(n) && Math.round(n) !== n;
    };

    MAX8 = 256;

    MAX16 = 256 * 256;

    MAX32 = 256 * 256 * 256 * 256;

    COLLECT_STATS = true;

    commonZJsonStrings = {};

    commonZJsonStringsGet = function() {
        var k, list;
        list = [];
        for (k in commonZJsonStrings) {
            if (commonZJsonStrings[k] > 2) {
                list.push(k);
            }
        }
        //return console.log(list.sort().join("\n"));
    };

    commonZJsonBytePattrns = {};

    commonZJsonBytePattrnsGet = function() {
        var e, j, k, len, list, ref, results, v;
        list = [];
        for (k in commonZJsonBytePattrns) {
            v = commonZJsonBytePattrns[k];
            list.push([k, v]);
        }
        list = list.sort(function(a, b) {
            return b[1] - a[1];
        });
        ref = list.slice(0, 256);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
            e = ref[j];
            //results.push(console.log(e[0], e[1]));
        }
        return results;
    };

    ZJson = (function() {
        ZJson.prototype.JSON_MARK = 90;

        ZJson.prototype.JSON_DIFF_MARK = 91;

        ZJson.prototype.OBJECT_MARK8 = 0x10;

        ZJson.prototype.OBJECT_MARK16 = 0x11;

        ZJson.prototype.ARRAY_MARK8 = 0x20;

        ZJson.prototype.ARRAY_MARK16 = 0x21;

        ZJson.prototype.ARRAY0_MARK = 0x22;

        ZJson.prototype.ARRAY1_MARK = 0x23;

        ZJson.prototype.ARRAY2_MARK = 0x24;

        ZJson.prototype.ARRAY3_MARK = 0x25;

        ZJson.prototype.ARRAY4_MARK = 0x26;

        ZJson.prototype.STRING_MARK8 = 0x30;

        ZJson.prototype.STRING_MARK16 = 0x31;

        ZJson.prototype.STRING_TABLE_MARK = 0x32;

        ZJson.prototype.NUMBER_MARK8 = 0x40;

        ZJson.prototype.NUMBER_MARK16 = 0x41;

        ZJson.prototype.NUMBER_MARK32 = 0x42;

        ZJson.prototype.NUMBER_MARK32F = 0x43;

        ZJson.prototype.BOOL_TRUE_MARK = 0x50;

        ZJson.prototype.BOOL_FALSE_MARK = 0x51;

        ZJson.prototype.NULL_MARK = 0x52;

        ZJson.prototype.UNDEFINED_MARK = 0x53;

        function ZJson(strTable) {
            var i, j, len, str;
            if (strTable == null) {
                strTable = null;
            }
            this.buffSize = 1024 * 1024;
            this.buffer = new ArrayBuffer(this.buffSize);
            this.dv = new DataView(this.buffer);
            this.str2num = new Map();
            this.num2str = new Map();
            if (strTable) {
                for (i = j = 0, len = strTable.length; j < len; i = ++j) {
                    str = strTable[i];
                    this.str2num.set(str, i);
                    this.num2str.set(i, str);
                }
                if (i > MAX16) {
                    throw "Too many strings in the string table";
                }
            }
        }

        ZJson.prototype.dumpDv = function(json) {
            var buf, dv, end, i, j, ref;
            this.i = 0;
            this.dumpNode(json);
            end = "END";
            this.dv.setUint8(this.i, end.charCodeAt(0));
            this.i += 1;
            this.dv.setUint8(this.i, end.charCodeAt(1));
            this.i += 1;
            this.dv.setUint8(this.i, end.charCodeAt(2));
            this.i += 1;
            buf = new ArrayBuffer(this.i);
            dv = new DataView(buf);
            for (i = j = 0, ref = this.i; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                dv.setUint8(i, this.dv.getUint8(i));
            }
            return dv;
        };

        ZJson.prototype.dumpNode = function(json) {
            var e, i, j, k, l, len, length, num, ref, results, results1, results2, v;
            if (json === null) {
                this.dv.setUint8(this.i, this.NULL_MARK);
                this.i += 1;
                return;
            }
            if (json === void 0) {
                this.dv.setUint8(this.i, this.UNDEFINED_MARK);
                this.i += 1;
                return;
            }
            switch (typeof json) {
                case "object":
                    if (json.length != null) {
                        length = json.length;
                        if (length === 0) {
                            this.dv.setUint8(this.i, this.ARRAY0_MARK);
                            this.i += 1;
                        } else if (length === 1) {
                            this.dv.setUint8(this.i, this.ARRAY1_MARK);
                            this.i += 1;
                        } else if (length === 2) {
                            this.dv.setUint8(this.i, this.ARRAY2_MARK);
                            this.i += 1;
                        } else if (length === 3) {
                            this.dv.setUint8(this.i, this.ARRAY3_MARK);
                            this.i += 1;
                        } else if (length === 4) {
                            this.dv.setUint8(this.i, this.ARRAY4_MARK);
                            this.i += 1;
                        } else if (length < MAX8) {
                            this.dv.setUint8(this.i, this.ARRAY_MARK8);
                            this.i += 1;
                            this.dv.setUint8(this.i, length);
                            this.i += 1;
                        } else if (length < MAX16) {
                            this.dv.setUint8(this.i, this.ARRAY_MARK16);
                            this.i += 1;
                            this.dv.setUint16(this.i, length);
                            this.i += 2;
                        } else {
                            throw "Array size of " + length + " not supproted";
                        }
                        results = [];
                        for (j = 0, len = json.length; j < len; j++) {
                            e = json[j];
                            results.push(this.dumpNode(e));
                        }
                        return results;
                    } else {
                        length = 0;
                        for (k in json) {
                            v = json[k];
                            length += 1;
                        }
                        if (length < MAX8) {
                            this.dv.setUint8(this.i, this.OBJECT_MARK8);
                            this.i += 1;
                            this.dv.setUint8(this.i, length);
                            this.i += 1;
                        } else if (length < MAX16) {
                            this.dv.setUint8(this.i, this.OBJECT_MARK16);
                            this.i += 1;
                            this.dv.setUint16(this.i, length);
                            this.i += 2;
                        } else {
                            throw "Object size of " + length + " not supproted";
                        }
                        results1 = [];
                        for (k in json) {
                            v = json[k];
                            this.dumpNode(k);
                            results1.push(this.dumpNode(v));
                        }
                        return results1;
                    }
                    break;
                case "number":
                    if (Math.round(json) === json && json > 0 && json < 256 * 256 * 256 * 256) {
                        if (json < MAX8) {
                            this.dv.setUint8(this.i, this.NUMBER_MARK8);
                            this.i += 1;
                            this.dv.setUint8(this.i, json);
                            return this.i += 1;
                        } else if (json < MAX16) {
                            this.dv.setUint8(this.i, this.NUMBER_MARK16);
                            this.i += 1;
                            this.dv.setUint16(this.i, json);
                            return this.i += 2;
                        } else if (json < MAX32) {
                            this.dv.setUint8(this.i, this.NUMBER_MARK32);
                            this.i += 1;
                            this.dv.setUint32(this.i, json);
                            return this.i += 4;
                        } else {
                            throw "Invalid number integer " + json + " not supported";
                        }
                    } else {
                        this.dv.setUint8(this.i, this.NUMBER_MARK32F);
                        this.i += 1;
                        this.dv.setFloat32(this.i, json);
                        return this.i += 4;
                    }
                    break;
                case "string":
                    num = this.str2num.get(json);
                    if (num != null) {
                        this.dv.setUint8(this.i, this.STRING_TABLE_MARK);
                        this.i += 1;
                        this.dv.setUint16(this.i, num);
                        return this.i += 2;
                    } else {
                        if (COLLECT_STATS) {
                            commonZJsonStrings[json] = (commonZJsonStrings[json] || 0) + 1;
                        }
                        length = json.length;
                        if (length < MAX8) {
                            this.dv.setUint8(this.i, this.STRING_MARK8);
                            this.i += 1;
                            this.dv.setUint8(this.i, json.length);
                            this.i += 1;
                        } else if (length < MAX16) {
                            this.dv.setUint8(this.i, this.STRING_MARK16);
                            this.i += 1;
                            this.dv.setUint16(this.i, json.length);
                            this.i += 2;
                        } else {
                            throw "String size of " + length + " not supproted";
                        }
                        results2 = [];
                        for (i = l = 0, ref = length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
                            this.dv.setUint8(this.i, json.charCodeAt(i));
                            results2.push(this.i += 1);
                        }
                        return results2;
                    }
                    break;
                case "boolean":
                    if (json === true) {
                        this.dv.setUint8(this.i, this.BOOL_TRUE_MARK);
                        return this.i += 1;
                    } else {
                        this.dv.setUint8(this.i, this.BOOL_FALSE_MARK);
                        return this.i += 1;
                    }
                    break;
                default:
                    throw "Type " + (typeof json) + " not supported";
            }
        };

        ZJson.prototype.loadDv = function(dv) {
            var json;
            this.i = 0;
            json = this.loadNode(dv);

            /*
      if COLLECT_STATS
             * look at common byte patterns
          bp = commonZJsonBytePattrns
          for i in [0...dv.byteLength]
              for pattern in [1...4]
                  if i + pattern < dv.byteLength
                      arr = []
                      for n in [0...pattern]
                          arr.push(dv.getUint8(i + n))
                      key = arr.join(",")
                      bp[key] = (bp[key] or 0) + 1
                      */
            return json;
        };

        ZJson.prototype.loadNode = function(dv) {
            var count, e, i, j, json, k, l, length, m, mark, num, ref, ref1, ref2, v;
            mark = dv.getUint8(this.i);
            this.i += 1;
            switch (mark) {
                case 0:
                    throw "Zero mark error";
                    break;
                case this.ARRAY_MARK8:
                case this.ARRAY_MARK16:
                case this.ARRAY0_MARK:
                case this.ARRAY1_MARK:
                case this.ARRAY2_MARK:
                case this.ARRAY3_MARK:
                case this.ARRAY4_MARK:
                    if (mark === this.ARRAY0_MARK) {
                        length = 0;
                    } else if (mark === this.ARRAY1_MARK) {
                        length = 1;
                    } else if (mark === this.ARRAY2_MARK) {
                        length = 2;
                    } else if (mark === this.ARRAY3_MARK) {
                        length = 3;
                    } else if (mark === this.ARRAY4_MARK) {
                        length = 4;
                    } else if (mark === this.ARRAY_MARK8) {
                        length = dv.getUint8(this.i);
                        this.i += 1;
                    } else if (mark === this.ARRAY_MARK16) {
                        length = dv.getUint16(this.i);
                        this.i += 2;
                    } else {
                        throw "Arrays mark error" + mark;
                    }
                    json = [];
                    for (count = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; count = 0 <= ref ? ++j : --j) {
                        e = this.loadNode(dv);
                        json.push(e);
                    }
                    return json;
                case this.OBJECT_MARK8:
                case this.OBJECT_MARK16:
                    if (mark === this.OBJECT_MARK8) {
                        length = dv.getUint8(this.i);
                        this.i += 1;
                    } else if (mark === this.OBJECT_MARK16) {
                        length = dv.getUint16(this.i);
                        this.i += 2;
                    } else {
                        throw "Objext mark error";
                    }
                    json = {};
                    for (count = l = 0, ref1 = length; 0 <= ref1 ? l < ref1 : l > ref1; count = 0 <= ref1 ? ++l : --l) {
                        k = this.loadNode(dv);
                        v = this.loadNode(dv);
                        json[k] = v;
                    }
                    return json;
                case this.STRING_TABLE_MARK:
                    num = dv.getUint16(this.i);
                    this.i += 2;
                    return this.num2str.get(num);
                case this.STRING_MARK8:
                case this.STRING_MARK16:
                    if (mark === this.STRING_MARK8) {
                        length = dv.getUint8(this.i);
                        this.i += 1;
                    } else if (mark === this.STRING_MARK16) {
                        length = dv.getUint16(this.i);
                        this.i += 2;
                    } else {
                        throw "String mark error";
                    }
                    json = "";
                    for (i = m = 0, ref2 = length; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
                        json += String.fromCharCode(dv.getUint8(this.i));
                        this.i += 1;
                    }
                    return json;
                case this.NUMBER_MARK8:
                    json = dv.getUint8(this.i);
                    this.i += 1;
                    return json;
                case this.NUMBER_MARK16:
                    json = dv.getUint16(this.i);
                    this.i += 2;
                    return json;
                case this.NUMBER_MARK32:
                    json = dv.getUint32(this.i);
                    this.i += 4;
                    return json;
                case this.NUMBER_MARK32F:
                    json = dv.getFloat32(this.i);
                    this.i += 4;
                    return json;
                case this.BOOL_TRUE_MARK:
                    return true;
                case this.BOOL_FALSE_MARK:
                    return false;
                case this.NULL_MARK:
                    return null;
                case this.UNDEFINED_MARK:
                    return void 0;
                default:
                    throw "Mark " + mark + " unkown";
            }
        };

        return ZJson;

    })();

    toHex = function(number, n) {
        var hex;
        if (n == null) {
            n = 4;
        }
        hex = number.toString(16);
        while (hex.length < n) {
            hex = "0" + hex;
        }
        return hex;
    };

    hexDisplay = function(dv) {
        var address, ascii, byte, bytes, i, j, r, results;
        i = 0;
        results = [];
        while (i < dv.byteLength) {
            address = toHex(i, 4);
            bytes = [];
            ascii = [];
            for (r = j = 0; j < 16; r = ++j) {
                if (i >= dv.byteLength) {
                    bytes.push("  ");
                    ascii.push(" ");
                } else {
                    byte = dv.getUint8(i);
                    bytes.push(toHex(byte, 2));
                    if ((20 < byte && byte < 128)) {
                        ascii.push(String.fromCharCode(byte));
                    } else {
                        ascii.push(".");
                    }
                }
                i += 1;
            }
            //results.push(console.log(address + "   " + bytes.join(" ") + "   " + ascii.join("")));
        }
        return results;
    };

}).call(this);

//from src/interpolator.js
// Generated by CoffeeScript 1.10.0
(function() {
    var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
        hasProp = {}.hasOwnProperty;

    Interpolator = (function() {
        function Interpolator(emitter) {
            this.step = 0;
            this.firstUpdate = true;
            this.players = [];
            this.particles = {};
            this.fastParticles = {};
            this.avgFrame = 9;
            this.lastFrame = 0;
            this.stepTime = now();
            this.t = now();
            this.avgDt = 1 / 60;
            this.avgTime = 1000 / 16;
            this.allMessages = [];
            this.dataQ = [];
            this.wait = 0;
            this.prevWait = 2;
            this.state = "waiting";
            this.pref = {};
            this.zJson = new ZJson(prot.commonWords);
            this.emitter = emitter;
        }

        Interpolator.prototype.gameStarted = function() {
            if (!commander) {
                return;
            }
            this.players = [];
            this.particles = {};
            this.winningSide = null;
            //track("start");
            return commander.selection = [];
        };

        Interpolator.prototype.gameEnded = function() {
        };

        Interpolator.prototype.recv = function(data) {
            this.dataQ.unshift(data);
            while (this.dataQ.length > 32) {
                this.process(this.dataQ.pop());
            }
            //return stats.simAdd();
        };

        Interpolator.prototype.process = function(data) {
            var t = now();
            var dt = t - this.stepTime;
            this.avgTime = this.avgTime * .9 + dt * .1;
            this.stepTime = t;
            this.avgFrame = this.avgFrame * .9 + this.lastFrame * .1;
            this.lastFrame = 0;
            if (this.players.length === 0 && !data.fullUpdate && commander) {
                //print("waiting for full update");
                return;
            }
            if (data.fullUpdate) {
                this.step = data.step;
            } else if (data.step != null) {
                if (this.step + 1 === data.step) {
                    this.step += 1;
                } else {
                    //console.log("Over step, what about full update?");
                    return;
                }
            }
            if (data.winningSide) {
                this.winningSide = data.winningSide;
            }
            if (data.state) {
                this.state = data.state;
            }
            if (this.state === "starting") {
                //this.gameStarted();
                this.emitter.emit('gamestarting');
            }
            if (this.state === "ended") {
                this.emitter.emit('gameended', {
                    players: this.players.filter(p => p.side === "alpha" || p.side === "beta"),
                    win: this.winningSide
                });
            }
            if (data.serverType) {
                this.serverType = data.serverType;
                this.emitter.emit('serverchange', this.serverType);
            }
            if (data.countDown != null) {
                this.countDown = data.countDown;
            }
            if (data.perf) {
                this.perf = data.perf;
            }
            if (data.things) {
            }
            if (data.players) {
                let ref5 = data.players;
                for (let s = 0; s < ref5.length; s++) {
                    let p = ref5[s];
                    let player = null;
                    for (let u = 0; u < p.length; u++) {
                        let kv = p[u];
                        let k = kv[0], v = kv[1];
                        if (k === "playerNumber") {
                            while (this.players.length <= v) {
                                this.players.push(new Player());
                            }
                            player = this.players[v];
                            player.number = v;
                        } else {
                            player[k] = v;
                        }
                    }
                }
            }
            let ref8 = this.players;
            for (let number = 0, y = 0; y < ref8.length; number = ++y) {
                let player = ref8[number];
                if ((typeof commander !== "undefined" && commander !== null) && (player != null ? player.ai : void 0) === false && commander.name === (player != null ? player.name : void 0)) {
                    if (player.side) {
                        commander.side = player.side;
                    }
                    if (player.money) {
                        commander.money = player.money;
                    }
                    if (player.selection) {
                        commander.selection = player.selection;
                    }
                    if (player.buildQ) {
                        commander.buildQ = player.buildQ;
                    }
                    if (player.validBar) {
                        commander.validBar = player.validBar;
                    }
                    if (player.rallyPoint) {
                        commander.rallyPoint = player.rallyPoint;
                    }
                    commander.number = number;
                    if (player.host != null) {
                        commander.host = player.host;
                    }
                }
                if (!player.name) {
                    player.name = "no name";
                }
                if (!player.side) {
                    player.side = "spectators";
                }
                if (!player.color) {
                    player.color = [255, 0, 0, 255];
                }
            }
            /*
            if (this.state === "starting") {
                this.state = "running";
            }
            if (this.state === "ended") {
                this.state = "waiting";
            }
            */
        };

        return Interpolator;

    })();

    var randColor = function(a) {
        return [Math.floor(a + (255 - a) * Math.random()), Math.floor(a + (255 - a) * Math.random()), Math.floor(a + (255 - a) * Math.random()), 255];
    };

    Player = (function() {
        Player.prototype.gainsMoney = true;

        Player.prototype.ready = false;

        Player.prototype.actions = 0;

        Player.prototype.apm = 0;

        Player.prototype.capps = 0;

        Player.prototype.kills = 0;

        Player.prototype.unitsBuilt = 0;

        Player.prototype.moneyEarned = 0;

        Player.prototype.moneyRatio = 1;

        Player.prototype.aiRules = null;

        Player.prototype.host = false;

        Player.prototype.ai = false;

        function Player(id1) {
            this.id = id1;
            this.side = this.id;
            this.color = randColor(200);
            this.reset();
        }

        Player.prototype.reset = function() {
            var n;
            this.money = 2000;//sim.defaultMoney;
            this.mouse = [0, 0];
            this.rallyPoint = [0, 0];
            this.selection = [];
            this.buildQ = [];
            this.validBar = (function() {
                var j, results;
                results = [];
                for (n = j = 0; j < 10; n = ++j) {
                    results.push(true);
                }
                return results;
            })();
            this.actions = 0;
            this.apm = 0;
            this.capps = 0;
            this.kills = 0;
            this.unitsBuilt = 0;
            this.moneyEarned = 0;
            return this.mouseTrail = [];
        };

        Player.prototype.earnMoney = function(amount) {
            amount *= this.moneyRatio;
            this.money += amount;
            return this.moneyEarned += amount;
        };

        Player.prototype.tick = function() {
            if (this.step % 16 === 0) {
                /*
                if (this.gainsMoney && sim.gainsMoney) {
                    this.earnMoney(10);
                }
                */
                this.apm = 9999;//this.actions / (sim.step / 16 / 60);
            }
            if (this.aiRules) {
                sim.timeIt("ai", (function(_this) {
                    return function() {
                        return doPlayerAIRules(_this);
                    };
                })(this));
            }
            //return this.wave();
        };

        return Player;

    })();


}).call(this);

module.exports.IstrolidClient = IstrolidClient;

/*
var repl = require('repl');
var ctx = repl.start().context;
ctx.IstrolidClient = IstrolidClient;
*/
